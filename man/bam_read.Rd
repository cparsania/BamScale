% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bam_read.R
\name{bam_read}
\alias{bam_read}
\title{Fast BAM reading with Bioconductor-compatible arguments}
\usage{
bam_read(
  file,
  param = NULL,
  what = NULL,
  tag = NULL,
  as = c("DataFrame", "data.frame", "GAlignments", "GAlignmentPairs", "scanBam"),
  seqqual_mode = c("compatible", "compact"),
  threads = 1L,
  BPPARAM = NULL,
  auto_threads = FALSE,
  use.names = FALSE,
  with.which_label = FALSE,
  include_unmapped = TRUE
)
}
\arguments{
\item{file}{A BAM input. Supported values are:
\itemize{
\item a single BAM path (\code{character(1)}) or multiple BAM paths,
\item a \code{Rsamtools::BamFile},
\item a \code{Rsamtools::BamFileList}.
}}

\item{param}{Optional \code{Rsamtools::ScanBamParam} (or a compatible list for
lightweight use). The following fields are honored:
\code{mapqFilter}, \code{flag}, \code{which}, \code{what}, and \code{tag}.}

\item{what}{Character vector of fields to return, similar to
\code{scanBam(what=...)}. Supported fields are
\code{qname}, \code{flag}, \code{rname}, \code{strand}, \code{pos}, \code{qwidth}, \code{mapq}, \code{cigar},
\code{mrnm}, \code{mpos}, \code{isize}, \code{seq}, \code{qual}.}

\item{tag}{Character vector of 2-letter tag names to extract.}

\item{as}{Output format:
\itemize{
\item \code{"DataFrame"}: returns \code{S4Vectors::DataFrame} (default),
\item \code{"data.frame"}: returns base \code{data.frame},
\item \code{"GAlignments"}: returns \code{GenomicAlignments::GAlignments},
\item \code{"GAlignmentPairs"}: returns \code{GenomicAlignments::GAlignmentPairs},
\item \code{"scanBam"}: returns a \code{scanBam()}-shaped list-of-lists.
}}

\item{seqqual_mode}{Controls representation of \code{seq}/\code{qual} when those
fields are requested:
\itemize{
\item \code{"compatible"} (default): return character vectors matching
\code{scanBam}-style expectations,
\item \code{"compact"}: return raw list-columns for faster/lower-overhead
extraction. This mode is currently supported for
\code{as = "data.frame"} or \code{as = "DataFrame"}.
}}

\item{threads}{Requested number of OpenMP threads used for
reading/decompression. May be capped when \code{auto_threads = TRUE}.}

\item{BPPARAM}{Optional \code{BiocParallel} parameter used when \code{file} contains
more than one BAM. If \code{NULL}, files are processed serially.}

\item{auto_threads}{Logical; when \code{TRUE} and \code{BPPARAM} has multiple workers,
BamScale automatically caps per-file OpenMP threads to avoid
oversubscription.}

\item{use.names}{Passed to alignment object conversion. When \code{TRUE}, read names
(\code{qname}) are used as object names.}

\item{with.which_label}{Logical; if \code{TRUE} and \code{param} includes \code{which},
an extra \code{which_label} column is returned.}

\item{include_unmapped}{Logical; whether unmapped records are retained
(subject to \code{param$flag} constraints).}
}
\value{
If \code{file} is length 1: one object in the format specified by \code{as}.
If \code{file} has length > 1 (or is a \code{BamFileList}): a named list of outputs,
one per BAM file.
}
\description{
\code{bam_read()} is a multithreaded sequential BAM reader built on top of
\code{ompBAM}. The interface is designed to be familiar to users of
\code{Rsamtools::scanBam()}, \code{GenomicAlignments::readGAlignments()}, and
\code{GenomicAlignments::readGAlignmentPairs()}.
}
\details{
\code{bam_read()} is intentionally column-compatible with common BAM fields used by
Bioconductor workflows and can be used as a fast drop-in reader before
conversion to downstream classes.

Parallelism model:
\itemize{
\item \code{BPPARAM} parallelizes across files (one file per BiocParallel worker).
\item \code{threads} parallelizes within each file via OpenMP.
\item Effective total concurrency is approximately
\code{min(length(file), BiocParallel::bpnworkers(BPPARAM)) * threads}.
\item If \code{auto_threads = TRUE} and \code{BPPARAM} has multiple workers, per-file
OpenMP threads are set to
\code{max(1, min(threads, floor(available_cores / workers_eff)))}, where
\code{workers_eff = min(length(file), BiocParallel::bpnworkers(BPPARAM))}.
}

Compatibility notes:
\itemize{
\item Region filtering via \code{param$which} is supported as a sequential filter
(not index-jump random access).
\item Flag filtering uses \code{ScanBamFlag} semantics by converting logical flag
requirements into required-set and required-unset bit masks.
\item Tag values are returned as character columns. Scalar tags are scalar
strings; \code{B} tags are comma-separated vectors.
\item \code{seqqual_mode = "compact"} is optimized for throughput-oriented
benchmarking and returns raw list-columns for \code{seq}/\code{qual}.
\item \code{"GAlignments"} and \code{"GAlignmentPairs"} output exclude unmapped records.
\item \code{as = "scanBam"} returns a strict scan-like list-of-lists:
without \code{param$which}, it returns one unnamed batch; with \code{param$which},
it returns one batch per range label (including empty ranges), with
requested \code{what} fields and \code{tag} values under \verb{$tag}.
If Biostrings is installed, \code{seq} and \code{qual} are returned as
\code{DNAStringSet} and \code{PhredQuality} for closer \code{scanBam()} compatibility.
}
}
\examples{
if (requireNamespace("ompBAM", quietly = TRUE)) {
  bam <- ompBAM::example_BAM("Unsorted")

  # Familiar scanBam-like field selection
  x <- bam_read(bam, what = c("qname", "flag", "rname", "pos", "cigar"))

  # Include sequence + quality
  y <- bam_read(bam, what = c("qname", "seq", "qual"), threads = 2)

  # scanBam-shaped output
  z <- bam_read(bam, what = c("qname", "flag"), tag = "NM", as = "scanBam")
}
}
