[{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"purpose","dir":"Articles","previous_headings":"","what":"Purpose","title":"BamScale vs Rsamtools Output Reproducibility","text":"vignette checks reproducibility comparing BamScale Rsamtools outputs BAM input. step1 fields: qname, flag, rname, pos, mapq, cigar seq+qual fields: qname, seq, qual keep comparison deterministic fair, tools run single-thread mode check.","code":""},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"input-bam","dir":"Articles","previous_headings":"","what":"Input BAM","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"bam <- ompBAM::example_BAM(\"Unsorted\")  cat(\"BAM:\", bam, \"\\n\") #> BAM: /home/runner/work/_temp/Library/ompBAM/extdata/THP1_ND_1.bam cat(\"Exists:\", file.exists(bam), \"\\n\") #> Exists: TRUE cat(\"Size (MB):\", round(file.size(bam) / 1024^2, 3), \"\\n\") #> Size (MB): 1.323"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"helper-functions","dir":"Articles","previous_headings":"","what":"Helper Functions","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"scanbam_to_df <- function(scan_rec, fields) {   cols <- vector(\"list\", length(fields))   names(cols) <- fields    lens <- integer(length(fields))    for (i in seq_along(fields)) {     nm <- fields[[i]]     v <- scan_rec[[nm]]      if (is.null(v)) {       next     }      if (nm %in% c(\"seq\", \"qual\", \"rname\")) {       v <- as.character(v)     }      cols[[i]] <- v     lens[[i]] <- length(v)   }    n <- if (any(lens > 0L)) max(lens) else 0L    for (i in seq_along(fields)) {     if (is.null(cols[[i]])) {       cols[[i]] <- rep(NA, n)     } else if (length(cols[[i]]) != n) {       if (length(cols[[i]]) == 1L && n > 1L) {         cols[[i]] <- rep(cols[[i]], n)       } else {         stop(\"Inconsistent field lengths in Rsamtools output for field: \", fields[[i]], call. = FALSE)       }     }   }    as.data.frame(cols, stringsAsFactors = FALSE) }  normalize_df <- function(df) {   out <- as.data.frame(df, stringsAsFactors = FALSE)    for (nm in names(out)) {     if (is.factor(out[[nm]])) out[[nm]] <- as.character(out[[nm]])     if (is.integer(out[[nm]]) || is.numeric(out[[nm]])) {       suppressWarnings(out[[nm]] <- as.integer(out[[nm]]))     } else {       out[[nm]] <- as.character(out[[nm]])     }   }    out }  compare_fields <- function(a, b, fields) {   stopifnot(all(fields %in% names(a)), all(fields %in% names(b)))    n <- min(nrow(a), nrow(b))   if (n == 0L) {     return(data.frame(       field = fields,       identical = NA,       stringsAsFactors = FALSE     ))   }    aa <- a[seq_len(n), fields, drop = FALSE]   bb <- b[seq_len(n), fields, drop = FALSE]    data.frame(     field = fields,     identical = vapply(fields, function(f) identical(aa[[f]], bb[[f]]), logical(1)),     stringsAsFactors = FALSE   ) }   preview_pair <- function(bs_df, rs_df, fields, n = 5L) {   n <- min(as.integer(n), nrow(bs_df), nrow(rs_df))   if (n <= 0L) {     return(data.frame())   }    bs_preview <- bs_df[seq_len(n), fields, drop = FALSE]   rs_preview <- rs_df[seq_len(n), fields, drop = FALSE]    bs_preview$tool <- \"BamScale\"   rs_preview$tool <- \"Rsamtools\"   bs_preview$row_id <- seq_len(n)   rs_preview$row_id <- seq_len(n)    out <- rbind(bs_preview, rs_preview)   out <- out[, c(\"row_id\", \"tool\", fields), drop = FALSE]   out }  kable_fit <- function(x) {   tbl <- knitr::kable(     x,     format = \"html\",     table.attr = 'class=\"repro-table\"'   )   knitr::asis_output(paste0('<div class=\"repro-scroll\">', tbl, '<\/div>')) }"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"step1-output-comparison","dir":"Articles","previous_headings":"","what":"Step1 Output Comparison","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"fields_step1 <- c(\"qname\", \"flag\", \"rname\", \"pos\", \"mapq\", \"cigar\")  bs_step1 <- BamScale::bam_read(   file = bam,   what = fields_step1,   as = \"data.frame\",   include_unmapped = TRUE,   threads = 1L,   auto_threads = FALSE )  rs_step1 <- Rsamtools::scanBam(   bam,   param = Rsamtools::ScanBamParam(what = fields_step1) )[[1]]  bs_step1_df <- normalize_df(bs_step1) rs_step1_df <- normalize_df(scanbam_to_df(rs_step1, fields_step1))  step1_cmp <- compare_fields(bs_step1_df, rs_step1_df, fields_step1)  summary_step1 <- data.frame(   rows_bamscale = nrow(bs_step1_df),   rows_rsamtools = nrow(rs_step1_df),   rows_compared = min(nrow(bs_step1_df), nrow(rs_step1_df)),   all_fields_identical = all(step1_cmp$identical),   stringsAsFactors = FALSE )  kable_fit(summary_step1) kable_fit(step1_cmp) cat(\"\\nQuick output preview (first matched rows):\\n\") #>  #> Quick output preview (first matched rows): kable_fit(preview_pair(bs_step1_df, rs_step1_df, fields_step1, n = 5L))"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"seq-qual-output-comparison","dir":"Articles","previous_headings":"","what":"Seq + Qual Output Comparison","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"fields_seqqual <- c(\"qname\", \"seq\", \"qual\")  bs_sq <- BamScale::bam_read(   file = bam,   what = fields_seqqual,   as = \"data.frame\",   seqqual_mode = \"compatible\",   include_unmapped = TRUE,   threads = 1L,   auto_threads = FALSE )  rs_sq <- Rsamtools::scanBam(   bam,   param = Rsamtools::ScanBamParam(what = fields_seqqual) )[[1]]  bs_sq_df <- normalize_df(bs_sq) rs_sq_df <- normalize_df(scanbam_to_df(rs_sq, fields_seqqual))  seqqual_cmp <- compare_fields(bs_sq_df, rs_sq_df, fields_seqqual)  summary_sq <- data.frame(   rows_bamscale = nrow(bs_sq_df),   rows_rsamtools = nrow(rs_sq_df),   rows_compared = min(nrow(bs_sq_df), nrow(rs_sq_df)),   all_fields_identical = all(seqqual_cmp$identical),   stringsAsFactors = FALSE )  kable_fit(summary_sq) kable_fit(seqqual_cmp) cat(\"\\nQuick output preview (first matched rows):\\n\") #>  #> Quick output preview (first matched rows): kable_fit(preview_pair(   bs_sq_df,   rs_sq_df,   fields_seqqual,   n = 5L ))"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"reproducibility-summary","dir":"Articles","previous_headings":"","what":"Reproducibility Summary","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"repro_tbl <- rbind(   data.frame(     workload = \"step1\",     rows_bamscale = nrow(bs_step1_df),     rows_rsamtools = nrow(rs_step1_df),     rows_compared = min(nrow(bs_step1_df), nrow(rs_step1_df)),     all_fields_identical = all(step1_cmp$identical),     stringsAsFactors = FALSE   ),   data.frame(     workload = \"seqqual\",     rows_bamscale = nrow(bs_sq_df),     rows_rsamtools = nrow(rs_sq_df),     rows_compared = min(nrow(bs_sq_df), nrow(rs_sq_df)),     all_fields_identical = all(seqqual_cmp$identical),     stringsAsFactors = FALSE   ) )  kable_fit(repro_tbl)"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"BamScale vs Rsamtools Output Reproducibility","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> loaded via a namespace (and not attached): #>  [1] crayon_1.5.3         cli_3.6.5            knitr_1.51           #>  [4] rlang_1.1.7          xfun_0.56            generics_0.1.4       #>  [7] textshaping_1.0.4    jsonlite_2.0.0       S4Vectors_0.48.0     #> [10] Biostrings_2.78.0    BamScale_0.99.0      htmltools_0.5.9      #> [13] stats4_4.5.2         ragg_1.5.0           sass_0.4.10          #> [16] rmarkdown_2.30       Seqinfo_1.0.0        evaluate_1.0.5       #> [19] jquerylib_0.1.4      bitops_1.0-9         fastmap_1.2.0        #> [22] IRanges_2.44.0       yaml_2.3.12          lifecycle_1.0.5      #> [25] compiler_4.5.2       codetools_0.2-20     fs_1.6.6             #> [28] Rcpp_1.1.1           XVector_0.50.0       BiocParallel_1.44.0  #> [31] systemfonts_1.3.1    digest_0.6.39        R6_2.6.1             #> [34] parallel_4.5.2       GenomicRanges_1.62.1 bslib_0.10.0         #> [37] tools_4.5.2          ompBAM_1.14.0        Rsamtools_2.26.0     #> [40] pkgdown_2.2.0        BiocGenerics_0.56.0  cachem_1.1.0         #> [43] desc_1.4.3"},{"path":"https://cparsania.github.io/BamScale/articles/output-comparison.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"BamScale vs Rsamtools Output Reproducibility","text":"Equality reported field level rows compared order. row counts differ, inspect filtering assumptions (flag, include_unmapped, , etc.) first. performance benchmarking, keep output check separate timing runs.","code":""},{"path":"https://cparsania.github.io/BamScale/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Chirag Parsania. Author, maintainer.","code":""},{"path":"https://cparsania.github.io/BamScale/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parsania C (2026). BamScale: Bioconductor-Friendly Multithreaded BAM Processing. R package version 0.99.0.","code":"@Manual{,   title = {Bioconductor-Friendly Multithreaded BAM Processing},   author = {Chirag Parsania},   year = {2026},   note = {R package version 0.99.0}, }"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"bamscale","dir":"","previous_headings":"","what":"Bioconductor-Friendly Multithreaded BAM Processing","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"BamScale multithreaded BAM processing package R built top ompBAM C++ engine. designed Bioconductor users need high-throughput BAM parsing preserving familiar scanBam/readGAlignments-style workflows.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"why-bamscale-in-bioconductor-workflows","dir":"","previous_headings":"","what":"Why BamScale in Bioconductor Workflows?","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"BamScale focuses three goals: speed modern multi-core systems, compatibility common Bioconductor input/output contracts, transparent benchmarking reproducibility. Key capabilities: OpenMP-enabled per-file parallelism via threads, optional multi-file parallelism via BiocParallel (BPPARAM), ScanBamParam-like filtering (mapqFilter, flag, , , tag), data.frame S4Vectors::DataFrame, GenomicAlignments::GAlignments, GenomicAlignments::GAlignmentPairs, scanBam-shaped list output (= \"scanBam\").","code":""},{"path":[]},{"path":"https://cparsania.github.io/BamScale/index.html","id":"prerequisites","dir":"","previous_headings":"Installation","what":"Prerequisites","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"R C++17 toolchain OpenMP-capable compiler/runtime ompBAM available R library","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"current-install-route-pre-bioconductor-release","dir":"","previous_headings":"Installation","what":"Current install route (pre-Bioconductor release)","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE)) {   install.packages(\"BiocManager\") } BiocManager::install(\"ompBAM\")  if (!requireNamespace(\"remotes\", quietly = TRUE)) {   install.packages(\"remotes\") } remotes::install_github(\"cparsania/BamScale\")"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"after-bioconductor-acceptance","dir":"","previous_headings":"Installation","what":"After Bioconductor acceptance","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"","code":"BiocManager::install(\"BamScale\")"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"","code":"library(BamScale)  bam <- ompBAM::example_BAM(\"Unsorted\")  # 1) Step1-style extraction x <- bam_read(   file = bam,   what = c(\"qname\", \"flag\", \"rname\", \"pos\", \"mapq\", \"cigar\"),   threads = 4 )  # 2) Seq/qual in comparator-compatible mode sq <- bam_read(   file = bam,   what = c(\"qname\", \"seq\", \"qual\"),   as = \"data.frame\",   seqqual_mode = \"compatible\",   threads = 4 )  # 3) Fast chromosome-level counts cnt <- bam_count(file = bam, threads = 4)"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"parallelism-model","dir":"","previous_headings":"","what":"Parallelism Model","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"BamScale can parallelize two axes: across files via BPPARAM workers, within file via OpenMP threads. Approximate effective concurrency: min(length(file), bpnworkers(BPPARAM)) * threads auto_threads = TRUE, BamScale can cap per-file threads multi-worker execution reduce oversubscription.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"reproducibility-and-output-equivalence","dir":"","previous_headings":"","what":"Reproducibility and Output Equivalence","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"dedicated vignette validates output comparability Rsamtools: vignettes/output-comparison.Rmd compares step1 fields seq+qual fields compatible mode Render locally:","code":"rmarkdown::render(\"vignettes/output-comparison.Rmd\")"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"benchmarking","dir":"","previous_headings":"","what":"Benchmarking","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"Benchmark assets inst/benchmarks/: runner: inst/benchmarks/run_server_benchmark.R report: inst/benchmarks/benchmark_report.qmd protocol: inst/benchmarks/README.md benchmark design separates two tracks: fair: cross-package comparisons (BamScale vs Rsamtools/GenomicAlignments) optimized: BamScale-optimizations (example compact seq/qual) separation intentional avoids mixing optimization-paths cross-package claims.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"interpreting-worker-vs-thread-scaling","dir":"","previous_headings":"","what":"Interpreting Worker vs Thread Scaling","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"workers always mean faster runtime fixed total CPU budget. multi-file BAM workloads, performance can drop workers increase per-worker threads shrink : worker/process overhead, memory serialization pressure, shared storage bandwidth contention. behavior unique BamScale can appear Rsamtools/GenomicAlignments multi-process patterns well. Benchmark reporting always state worker/thread allocation explicitly.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"current-limitations","dir":"","previous_headings":"","what":"Current Limitations","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"param$currently implemented sequential filtering rather indexed random-access jumps. seqqual_mode = \"compact\" optimization-oriented intended strict cross-package output-equivalence comparisons. GAlignments GAlignmentPairs outputs exclude unmapped records design.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"community-and-support","dir":"","previous_headings":"","what":"Community and Support","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"https://support.bioconductor.org https://github.com/cparsania/BamScale/issues posting performance reports, include: package versions, hardware/storage context, exact benchmark command profile, threads/BPPARAM settings.","code":""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"BamScale contributes performance claims, please also cite ompBAM.","code":"citation(\"BamScale\")"},{"path":"https://cparsania.github.io/BamScale/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"Pull requests welcome. Please include: short motivation, tests behavior changes, benchmark evidence performance claims. opening PR, run:","code":"R CMD build . R CMD check --as-cran BamScale_*.tar.gz Rscript -e \"BiocCheck::BiocCheck('.')\""},{"path":"https://cparsania.github.io/BamScale/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Bioconductor-Friendly Multithreaded BAM Processing","text":"MIT (LICENSE).","code":""},{"path":"https://cparsania.github.io/BamScale/reference/BamScale-package.html","id":null,"dir":"Reference","previous_headings":"","what":"BamScale: Bioconductor-Friendly Multithreaded BAM Processing — BamScale-package","title":"BamScale: Bioconductor-Friendly Multithreaded BAM Processing — BamScale-package","text":"Multithreaded sequential BAM processing built top ompBAM C++ engine. BamScale provides user-friendly BAM read scan interfaces designed compatibility existing Bioconductor workflows.","code":""},{"path":"https://cparsania.github.io/BamScale/reference/BamScale-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BamScale: Bioconductor-Friendly Multithreaded BAM Processing — BamScale-package","text":"Maintainer: Chirag Patel chirag@example.com","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count BAM records with Bioconductor-compatible filtering — bam_count","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"bam_count() provides fast chromosome-level count summary, honoring key filtering fields ScanBamParam (mapqFilter, flag, ).","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"","code":"bam_count(   file,   param = NULL,   threads = 1L,   BPPARAM = NULL,   auto_threads = FALSE,   include_unmapped = TRUE )"},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"file BAM input (character, BamFile, BamFileList). param Optional Rsamtools::ScanBamParam (compatible list). threads Requested number OpenMP threads. May capped auto_threads = TRUE. BPPARAM Optional BiocParallel parameter multi-file operation. auto_threads Logical; TRUE BPPARAM multiple workers, BamScale automatically caps per-file OpenMP threads avoid oversubscription. include_unmapped Whether include extra * row unmapped records.","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"one file: data.frame columns seqname, seqlength, count. multiple files: named list data.frames.","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"Parallelism behavior matches bam_read(): BPPARAM distributes work across BAM files, threads controls OpenMP work within file. auto_threads = TRUE BPPARAM multiple workers, per-file OpenMP threads capped using max(1, min(threads, floor(available_cores / workers_eff))), workers_eff = min(length(file), BiocParallel::bpnworkers(BPPARAM)).","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count BAM records with Bioconductor-compatible filtering — bam_count","text":"","code":"if (requireNamespace(\"ompBAM\", quietly = TRUE)) {   bam <- ompBAM::example_BAM(\"Unsorted\")   bam_count(bam, threads = 2) } #>    seqname seqlength count #> 1        1 248956422  1308 #> 2       10 133797422   308 #> 3       11 135086622   600 #> 4       12 133275309   648 #> 5       13 114364328   162 #> 6       14 107043718   230 #> 7       15 101991189   294 #> 8       16  90338345   334 #> 9       17  83257441   570 #> 10      18  80373285    78 #> 11      19  58617616   600 #> 12       2 242193529   586 #> 13      20  64444167   168 #> 14      21  46709983    76 #> 15      22  50818468   200 #> 16       3 198295559   454 #> 17       4 190214555   252 #> 18       5 181538259   516 #> 19       6 170805979   824 #> 20       7 159345973   412 #> 21       8 145138636   452 #> 22       9 138394717   372 #> 23      MT     16569   288 #> 24       X 156040895   254 #> 25       Y  57227415    14 #> 26       *        NA     0"},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"bam_read() multithreaded sequential BAM reader built top ompBAM. interface designed familiar users Rsamtools::scanBam(), GenomicAlignments::readGAlignments(), GenomicAlignments::readGAlignmentPairs().","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"","code":"bam_read(   file,   param = NULL,   what = NULL,   tag = NULL,   as = c(\"DataFrame\", \"data.frame\", \"GAlignments\", \"GAlignmentPairs\", \"scanBam\"),   seqqual_mode = c(\"compatible\", \"compact\"),   threads = 1L,   BPPARAM = NULL,   auto_threads = FALSE,   use.names = FALSE,   with.which_label = FALSE,   include_unmapped = TRUE )"},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"file BAM input. Supported values : single BAM path (character(1)) multiple BAM paths, Rsamtools::BamFile, Rsamtools::BamFileList. param Optional Rsamtools::ScanBamParam (compatible list lightweight use). following fields honored: mapqFilter, flag, , , tag. Character vector fields return, similar scanBam(=...). Supported fields qname, flag, rname, strand, pos, qwidth, mapq, cigar, mrnm, mpos, isize, seq, qual. tag Character vector 2-letter tag names extract. Output format: \"DataFrame\": returns S4Vectors::DataFrame (default), \"data.frame\": returns base data.frame, \"GAlignments\": returns GenomicAlignments::GAlignments, \"GAlignmentPairs\": returns GenomicAlignments::GAlignmentPairs, \"scanBam\": returns scanBam()-shaped list--lists. seqqual_mode Controls representation seq/qual fields requested: \"compatible\" (default): return character vectors matching scanBam-style expectations, \"compact\": return raw list-columns faster/lower-overhead extraction. mode currently supported = \"data.frame\" = \"DataFrame\". threads Requested number OpenMP threads used reading/decompression. May capped auto_threads = TRUE. BPPARAM Optional BiocParallel parameter used file contains one BAM. NULL, files processed serially. auto_threads Logical; TRUE BPPARAM multiple workers, BamScale automatically caps per-file OpenMP threads avoid oversubscription. use.names Passed alignment object conversion. TRUE, read names (qname) used object names. .which_label Logical; TRUE param includes , extra which_label column returned. include_unmapped Logical; whether unmapped records retained (subject param$flag constraints).","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"file length 1: one object format specified . file length > 1 (BamFileList): named list outputs, one per BAM file.","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"bam_read() intentionally column-compatible common BAM fields used Bioconductor workflows can used fast drop-reader conversion downstream classes. Parallelism model: BPPARAM parallelizes across files (one file per BiocParallel worker). threads parallelizes within file via OpenMP. Effective total concurrency approximately min(length(file), BiocParallel::bpnworkers(BPPARAM)) * threads. auto_threads = TRUE BPPARAM multiple workers, per-file OpenMP threads set max(1, min(threads, floor(available_cores / workers_eff))), workers_eff = min(length(file), BiocParallel::bpnworkers(BPPARAM)). Compatibility notes: Region filtering via param$supported sequential filter (index-jump random access). Flag filtering uses ScanBamFlag semantics converting logical flag requirements required-set required-unset bit masks. Tag values returned character columns. Scalar tags scalar strings; B tags comma-separated vectors. seqqual_mode = \"compact\" optimized throughput-oriented benchmarking returns raw list-columns seq/qual. \"GAlignments\" \"GAlignmentPairs\" output exclude unmapped records. = \"scanBam\" returns strict scan-like list--lists: without param$, returns one unnamed batch; param$, returns one batch per range label (including empty ranges), requested fields tag values $tag. Biostrings installed, seq qual returned DNAStringSet PhredQuality closer scanBam() compatibility.","code":""},{"path":"https://cparsania.github.io/BamScale/reference/bam_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast BAM reading with Bioconductor-compatible arguments — bam_read","text":"","code":"if (requireNamespace(\"ompBAM\", quietly = TRUE)) {   bam <- ompBAM::example_BAM(\"Unsorted\")    # Familiar scanBam-like field selection   x <- bam_read(bam, what = c(\"qname\", \"flag\", \"rname\", \"pos\", \"cigar\"))    # Include sequence + quality   y <- bam_read(bam, what = c(\"qname\", \"seq\", \"qual\"), threads = 2)    # scanBam-shaped output   z <- bam_read(bam, what = c(\"qname\", \"flag\"), tag = \"NM\", as = \"scanBam\") }"}]
